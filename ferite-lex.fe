uses "regexp";

class Flexer {
	
	array contexts;
	array contextStack;
	
	function context( string context ) {
		object contextObject;
		if( not .contexts.keyExists(context) )
			.contexts[context] = new FlexerContext( context, .contexts.size() );
		contextObject = .contexts[context];
		if( recipient() ) {
			deliver( contextObject );
		}
		return contextObject;
	}
	function defaultContext() {
		return .context('FlexerDefault') using recipient();
	}
	string text = '';
	function start( string text ) {
		.contextStack = [];
		.pushContext('FlexerDefault');
		.text = text;
		.contexts.each() using ( context ) {
			context.finalise();
		};
	}
	function streamLeft() {
		return (.text.length() > 0 ? true : false);
	}
	number lastToken;
	array  tokenStack;
	
	function lex() {
		boolean tokenRecieved = false;
		.lastToken = 0;
		while( .tokenStack ) {
			.lastToken = .tokenStack[0]['Token'];
			.attachedObject = null;
			if( .tokenStack[0]['AttachedObject'] isa object )
				.attachedObject = .tokenStack[0]['AttachedObject'];
			.tokenStack.shift();
			return .lastToken;
		}
		while( not tokenRecieved ) {
			array r;
			.attachedObject = null;
			r = .contextStack.last().match( self, .text );
			if( r['TokenLength'] > 0 ) {
				if( r['TokenLength'] < .text.length() )
					.text = .text[r['TokenLength']..];
				else if( r['TokenLength'] == .text.length() )
					.text = '';
					
				if( r['ActionReturn'] isa number ) {
					.lastToken = r['ActionReturn'];
					break;
				} else if( r['ActionReturn'] isa array ) {
					.tokenStack = r['ActionReturn'];
					.lastToken = .tokenStack[0]['Token'];
					.attachedObject = null;
					if( .tokenStack[0]['AttachedObject'] isa object )
						.attachedObject = .tokenStack[0]['AttachedObject'];
					.tokenStack.shift();
					return .lastToken;
				} else {
					continue;
				}
			}
			break;
		}
		return .lastToken;
	}
	function pushContext( string name )
		.contextStack.push( .context(name) );
	function pushDefaultContext()
		.contextStack.push( .context('FlexerDefault') );
	function popContext() 
		.contextStack.pop();
		
	object attachedObject;
	function attach( object o )
		.attachedObject = o;
}

class FlexerContext {
	
	string name;
	number id;
	
	constructor( string name, number id ) {
		.name = name;
		.id = id;
	}
	
	array tokens;
	array order;
	
	function token( string token, string match, void action ) {
		.tokens[token] = [ 'Token' => token, 'Match' => match, 'Action' => action ];
		.order[] = token;
	}
	function token( string token, string match ) {
		object o = recipient();
		if( o )
			.token( token, match, o );
		else
			raise new Error( 'Expecting a closure!' );
	}
	function token( string match ) {
		object o = recipient();
		return .token( 'Token' + .order.size(), match, o );
	}
	function token( string match, object action )
		return .token( 'Token' + .order.size(), match, action );
	function token( string match, number token )
		return .token( 'Token' + .order.size(), match, token );

	function lexicon() {
		string lexicon = '^(' + .order.join('|') using ( key ) { return "(?P<$key>${.tokens[key]['Match']})"; } + ')';
		return lexicon;
	}
	
	object regexp;
	function finalise() {
		if( not .regexp ) {
			.token( 'UNKNOWN', '.', closure( flexer, token ) { return token.charToNum(); } );
			.regexp = new Regexp(.lexicon(), 'gs');
		}
	}
	function match( object flexer, string text ) {
		object match = null;
		array  captures = [];
		number tokenLength = 0;
		void   invokeReturn;
		
		match = .regexp.match( text );
		if( match ) {
			captures = match.captures();
			.order.each() using ( key ) {
				if( captures[key] ) {
					void action = .tokens[key]['Action'];
					if( action isa object and action )
						invokeReturn = action.invoke( flexer, captures[key] );
					else if( action isa number ) 
						invokeReturn = action;
					tokenLength = captures[key].length();
					return false;
				}
			};
		}
		return [ 'TokenLength' => tokenLength, 'ActionReturn' => invokeReturn ];
	}
}

