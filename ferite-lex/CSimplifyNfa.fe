/**
* Extract character classes from NFA and simplify.
 * @author C. Scott Ananian 25-Jul-1999
 */
class CSimplifyNfa
{
    private array<int> ccls; // character class mapping.
    private number original_charset_size; // original charset size
    private number mapped_charset_size; // reduced charset size
    
    function simplify( object<CSpec> m_spec ) {
        .computeClasses(m_spec); // initialize fields.
        
        // now rewrite the NFA using our character class mapping.
        Array.each( m_spec ) using ( /*object CNfa*/nfa ) {
            if( nfa.m_edge == CNfa.EMPTY || nfa.m_edge==CNfa.EPSILON )
                return; // no change.
            if( nfa.m_edge == CNfa.CCL ) {
                object<CSet> ncset = new CSet();
                ncset.map(nfa.m_set, .ccls); // map it.
                nfa.m_set = ncset;
            } else { // single character
                nfa.m_edge = .ccls[nfa.m_edge]; // map it.
            }
        };
        
        // now update m_spec with the mapping.
        m_spec.m_ccls_map = ccls;
        m_spec.m_dtrans_ncols = mapped_charset_size;
    }
    /** Compute minimum set of character classes needed to disambiguate
        *  edges.  We optimistically assume that every character belongs to
        *  a single character class, and then incrementally split classes
        *  as we see edges that require discrimination between characters in
        *  the class. [CSA, 25-Jul-1999] */
    private function computeClasses(object<CSpec> m_spec) {
        self.original_charset_size = m_spec.m_dtrans_ncols;
        Array.resize( self.ccls, original_charset_size ); // initially all zero.
        
        number nextcls = 1;
        object<SparseBitSet> clsA = new SparseBitSet(), clsB = new SparseBitSet();
        array<Hashtable> h;
        
        Console.print("Working on character classes.");
        Array.each( m_spec ) using ( /*object CNfa*/nfa ) {
            number i = 0;
            
            if (nfa.m_edge==CNfa.EMPTY || nfa.m_edge==CNfa.EPSILON)
                return; // no discriminatory information.
            clsA.clearAll(); clsB.clearAll();
            for (i=0; i< Array.size(.ccls); i++)
            {
                if (nfa.m_edge==i || // edge labeled with a character
                    nfa.m_edge==CNfa.CCL && nfa.m_set.contains(i)) // set of characters
                    clsA.set(.ccls[i]);
                else
                    clsB.set(.ccls[i]);
            }
            // now figure out which character classes we need to split.
            clsA.AND(clsB); // split the classes which show up on both sides of edge
            Console.print(clsA.size()==0?".":":");
            if (clsA.size()==0) return; // nothing to do.
                                          // and split them.
            h = []; // h will map old to new class name
            for (i=0; i<Array.size(.ccls); i++)
            {
                if (clsA[.ccls[i]])) // a split class
                {
                    if (nfa.m_edge==i || nfa.m_edge==CNfa.CCL && nfa.m_set.contains(i)) 
                    {
                        // on A side
                        if( !Array.keyExists( h, .ccls[i] ) )
                            h[.ccls[i]] = nextcls++; // make new class
                        .ccls[i] = h[.ccls[i]];
                    }
                }
            }
        };
        Console.println("");
        Console.println("NFA has "+nextcls+" distinct character classes.");
        
        self.mapped_charset_size = nextcls;
    }
}